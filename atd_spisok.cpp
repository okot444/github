/* ?????? ??????? ? ????. ?? ????? ?????? ?????????? ?????? ?????????.
??? - ??????
l - ??????
p - ??????? 
x - ??????
1. End(l) - ??????? ????? ?????????? ??-?? ??????
2. Insert(x,p,l) - ??????? ??????? ? ??????? a(1) ... a(p-1),x,a(p+1)... a(n) 
    (??????? ????? x ??????????)
    ??????? ? End(l): a(1) ... a(n), x
    ???? ??????? p ???, ?? ????????? ???????????
3. Locate(x,l) - ?????????? ??????? p ??????? x ? ?????? l
    ???? ???, ?? ???-??  p = End(l)
    ???? ?????????, ?? ???-?? p = ?????? ????????? 
4. Retrieve (p,l) - ????????? ?????? ?? ??????? ? ??????
    ???? p = End(l)  ??? p ??? ? ?????? , ?? ????????? ???????????
5. Delete (p,l) - ??????? ??????? ? ??????? p ? ?????? l
    a(1), a(2), ... a(p-1), a(p+1), ... a(n)
6. Next(p,l) - ?????????? ??????? ?????????? 
7. Previous(p,l) -  ?????????? ??????? ??????????? 
    ???? p - ?????????, ?? Next(p,l) = End(l)
    ???? p - ??????, ?? Previous(p,l) ????????? ???????????
    ???? p = End(l) ??? ??? ? ??????, ?? ???????????? ??????
8. Makenull (l) - ?????? ?????? ??????
9. First(l) - ?????????? ?????? ??????? ? ?????? l
    ???? l - ??????, ?? ???????????? ??????? End(l)
10. Print(l) - ??????? ???????? ? ??????? ?? ???????????? ? ??????

*/



// ??????
//#define N 20
//#define A 30 
#include <string.h>
#include <stdio.h>
#include <iostream>
using namespace std;
struct object
{
    static const int N = 20;
    static const int A = 30;

    char name [N];
    char address [A];
    int operator == (const object& p) const;// ........
    friend ostream& operator << (ostream& out, const object& a);

    object(const char n[], const char a[]);
    object();
};

ostream& operator << (ostream& out, const object& a)
{
    //cout<< "<<"<<endl;
    //for (int i=0; i<a.N; i++){
        cout<<a.name <<' '<< a.address<<endl;
  //  }
    return out;
}
int object:: operator == (const object& p) const
{
    if (strcmp(p.name,name) && strcmp(p.address,address) )
        return 0;
    return 1;
}
object::object()
{
    name[0] = '\0';
    address[0] = '\0';
}
object:: object(const char n[], const char a[])
{
    strcpy(name,n);
    strcpy(address, a);

}
using namespace std;

namespace array
{
    typedef int position; 
    class list
    {
    public:
        list ();
        position End();
        
        void Insert( object x, position p);
        position Locate( object x );
        object Retrieve( position p ); // 
        position Deletex( position p );
        position Next( position p );
        position Previous( position p );
        void Makenull(); // ? 
        position First();
        void Print();
    private:
        int last; // ?????? ?????????
        static const int size = 20;
        object m [size];
    };
    list:: list ()
    {
        last =0;

    }

    object a;// ?????????, //////// ??????? (?)
    position list:: End()
    {
        return last;

    }
    void list:: Insert( object x, position p ) //////
    {
        if (p > last || p < 0){  // ????????? ?????????? ?? ???????
            cout<< "position is missing"<<endl;
            return ;
        }
        if (last == size+1) //???????? ??????? ? ??????????? ??????, last
            return;
        for ( int i=last; i>p; i--)  // ???????, ??? ???????? ????? ??????? p ??????????
            m[i] = m[i-1];
        m[p] = x;
        last++;
       

    }
    position list:: Locate( object x )
    {
        int i=0;
        while ( i < last){
            if (m[i] == x)
                return i;
            i++;
        }
        return last; // ???? ??? ? ??????


    }
    object list:: Retrieve(position p)
    {
        if (p >= last || p<0)
            return a;
        return m[p];
    }
    position list:: Deletex( position p )
    {
        if (p >= last || p<0)
            return p ;
        for (int i=p; i<last-1; i++)
            m[i] = m[i+1];
        last--;
        return p;
    }
    position list:: Next( position p )
    {
        if (p >= last || p<0)
            return -1;
        /*if (p == size)  
            return last;*/
        return p+1;
    }
    position list:: Previous( position p )
    {
        if (p >= last || p<=0)
            return -1;
        return p-1;
    }
    void list:: Makenull()
    {
        last=0;
    }
    position list:: First()
    {
        return 0;
    }
    void list:: Print()
    {
        cout<<"print"<<endl;
        if (last == 0)
            cout<<"empty"<<endl;
        for ( int i=0; i<last; i++)
            cout<<i<< ": "<< m[i] <<endl;
    }

    
}
// ??????? ??????
namespace linkedlist
{
    struct elem;
    typedef elem* position; 
    
    struct elem
    {
        object o;
        position next;
        elem();
        int operator == (const elem& p)const;
    };
    
    elem:: elem() // ??? ?????????? ????????
    {
        o.name[0] = '\0';
        o.address[0] = '\0';
        next = this;
    }
    class list
    {
    public:
        list():head(NULL) {}
        ~list() { release(); }
        position End() const;
        void Insert(object x, position p);
        position Locate(object x) const;
        object& Retrieve (position p) const; // ?
        position Deletex (position p);
        position Next (position p) const;
        position Previous (position p)  const;
        void Makenull (); // ? 
        void Print() const;
        void release();
        position First () const;
        
        void set (char const *tname, char const *taddress);
        
        void printob(position p) { }
    private:
      elem* head;
      elem* delhead();
      elem* deltail();
      elem* next_p(elem* p);
      elem* previous_p(elem* p);
      position search(position p) const; // ????? ???????
      position search_pred(position p) const; // ????? ???????????

    };
    elem a;// ????????? ???????
    int elem:: operator == (const elem& p) const
    {
        if (strcmp(p.o.name,o.name) && strcmp(p.o.address,o.address) )
            return 0;
        return 1;
    }
    position list::search_pred(position p) const
    {
        position temp;
        while (temp->next != p) // ??????? ??????????
            temp = temp->next;
        return temp;
    }
    position list::search(position p) const // ????? ???????
    //?????????? NULL, ???? ??????? ???
    {
        position q=head;
        while ( q!=NULL && q!=p){// ????
            q=q->next;
        }
        return q;
    }
    elem* list:: delhead()// 
    {
        elem*temp=head;
        head = head->next;
        delete temp;
        return head;
    }
    elem* list:: deltail()//
    {
        elem*temp=head;
        head = head->next;
        delete temp;
        return head;
    }
    void list::release()
    {
        while(head)
            delhead();
    }
    position list:: End() const
    {
        return NULL;
    }
    
    void list:: Insert(object x,position p) // ????????? ???????? //
    {
        position q = search(p); // ?????????? ?? ???????
        if (q != p ) // ??????? ??? ? ?????? ? ??????? ?? ????? ?????????? ????
        {
            cout << "position doesn't exist"<<endl;
            return;
        }
        // ???????? ???????? 
        elem* el = new elem;      
        el->o = x;
        el->next = NULL;

        if (p == NULL) // ??????? End, 
        {
            if (head == NULL){ //?????????? ???????, ?????????  head
                head = el;
                return ;
            }
            q = head;
            //q = search_pred(NULL); // ???????? ?? ??????
            while (q->next != NULL) // 
                q=q->next;
            q->next = el;
            return;
            
        }
       // ???????? ?? ????? ???????, (?? endl)
        // q- ??????? ? ??????
        if (p == head){ // ??????? ? ??????
            el->next = head;
            head = el;
            return;
        }
        q = head;
        //q = search_pred(p); // ???????? ?? ?????????? ???????
        while (q->next != p)
            q=q->next;
        el->next = p;
        q->next = el;
    }
    position list::  Locate(object x) const 
    // ?????????? ??????? ??????? x
    {
        elem* h = head;
        while (h ){ //????? ?? ?????
            if ( h->o == x)
                return h;
            h=h->next;
        }
        return NULL; // ???? ???, ?? ?????????? ????? end(l)
    }
    object& list:: Retrieve (position p) const // ?
   // ????????? ?????? ?? ??????? ? ??????
    {
        position q = search(p); // ?????????? ?? ???????
        if (q != p || q==NULL){ // ??????? ???
            return a.o; // ?????????? ????????? ??????
        }
        return q->o;
    }
    position list::  Deletex (position p) // void ????????? ???????
    {
        // ???????? ?????????? ? 
        //?????????? ?? ???????
        position q = search(p); // ?????????? ?? ???????
        if (q != p ) // ??????? ??? ? ?????? 
        {
            cout << "position doesn't exist"<<endl;
            return p;
        }
        
        if (p == head){ // ???????? ??????
            head = delhead();
            return head; //(p->next)
        }
        //position temp =  search_pred(p);// ????? ??????????
        position temp = head;
        while (temp->next != p) // ??????? ??????????
            temp = temp->next;

        if (p->next == NULL)// ???????? ??????
        {
            temp->next = NULL;
            delete p;
            return temp->next; // 
        }
        // ???????? ? ????????
        temp->next = p->next;
        delete p;
        return temp->next; // ??????? p 
    }
    position list:: Next(position p) const
    {
        position q = search (p);
        if (q != p) // ??????? ???
            return a.next;
        if (p->next == NULL) // ???? p-?????????
            return NULL;
        return p->next;
    }
    position list:: Previous(position p) const // ?????????? ??????? ??????????? (q)
    {
        position q = search (p);
        if (q != p) // ??????? ???
            return a.next;
        if ( p == head) // ???? p - ?????? , ?? ?????????? ??????? ?????????? ???????
            return a.next;
        q = search_pred(p);// ??????? ??????? ? ???????? ?? ???????????
        return q;
    }
    void list:: Makenull ()
    {
        position p=head;
        while (head!=NULL){
            head=head->next;
            delete p;
            p=head;
        }
    } 
    position list:: First () const
    {
        if (head)
            return head;
        return NULL;

    }
    void list:: Print() const
    {
        cout<<"print"<<endl;
        position p = head;
        if (p == NULL){
            cout<< "empty" <<endl;
            return;
        }
        while (p){
           // ?????? ???????
           cout<< p->o.name<<' '<<p->o.address<<endl;
           cout<<endl;
           p=p->next;
        }
    }
}

namespace doublelinkedlist
{
    struct elem;
    typedef elem* position; 
   /* struct pair //?????
    {
        elem*begin;
        elem*end;
    };*/
    struct elem
    {
        object o;
        position next;
        position prev;
        elem();
        int operator == (const elem& p)const;
    };
    
    elem:: elem() // ??? ?????????? ????????
    {
        o.name[0] = '\0';
        o.address[0] = '\0';
        next = this;
        prev = this;
    }
    class list
    {
    public:
     //   list() {pair *pr = new pair; pr->begin =  NULL; pr->end = NULL;}
        list() : begin(NULL), end(NULL) {} //{ begin = NULL; end=NULL;}
        ~list() { release(); }
        position End() const;
        void Insert(object x, position p);
        position Locate(object x) const;
        object& Retrieve (position p) const; // ?
        position Deletex (position p);
        position Next (position p) const;
        position Previous (position p)  const;
        void Makenull (); //
        position First () const;
        void Print() const;
        
        void set (char const *tname, char const *taddress);
        
        
        // ??????????? ?? ??-?
        
    private:
        //void delhead(pair*pr,elem*p);
        position search(position p) const ;
        void release();
        void printob(position p) { }
       // pair *pr;
       elem* begin;
       elem* end;


    };
    elem a;// ????????? ???????
    /*void list:: delhead(pair*pr,elem*p) // ???????? ? ??????
    {
        pr->begin=p->next;
        p->next->prev=NULL;
        delete p;
    }*/
    void list:: release()
    {
        if (begin){
            while(begin->next){
                 begin = begin->next;
                 delete begin->prev;
                 begin->prev = NULL;
            }
            delete begin;
            begin = end =NULL;
        }
    }
    position list:: search(position p) const // ????? ???????
    //?????????? NULL, ???? ??????? ???
    {
        position q=begin;
        //while ( q->next!=NULL || q!=p){ // ?
        while (q!= NULL && q!=p){
            q=q->next;
        }
        return q;
    }
    position list:: End() const
    {
        return NULL;
    }
    void list:: Insert(object x,position p) // ????????? ???????? //
    {
        position q = search(p); // ?????????? ?? ???????
        //if (q != p && q!=NULL) // ??????? ??? ? ?????? ? ??????? ?? ????? ?????????? ????
        if (q != p)
        {
            cout << "position doesn't exist"<<endl;
            return;
        }
        // ???????? ???????? 
        elem* el = new elem;      
        el->o = x;
        el->next = NULL;
        el->prev = NULL;

        if (p == NULL) // ??????? End, 
        {
            if (begin == NULL){ //?????????? ??????? (?????? ??????) , ?????????  begin
                begin = end = el;
                return ;
            }
            // ???????? ??????
            //position temp = end;
            end->next = el;
            el->prev = end;
            end = el;
           
            return;
        }
       // ???????? ?? ????? ??????? p
        // q- ??????? ? ??????
        if (p == begin){ // ??????? ? ??????
            begin->prev = el;
            el->next = begin;
            begin = el;
            return;
        }
        // ??????? ? ????????
        /*q = begin;
        //q = search_pred(p); // ???????? ?? ?????????? ???????
        while (q->next != p)
            q=q->next;*/
        el->prev = p->prev;
        el->prev->next = el;
        p->prev = el;
        el->next = p;
    }
    position list::  Locate(object x) const 
    // ?????????? ??????? ??????? x
    {
        elem* h = begin;
        while (h ){ //????? ?? ?????
            if ( h->o == x)
                return h;
            h=h->next;
        }
        return NULL; // ???? ???, ?? ?????????? ????? end(l)
    }
    object& list:: Retrieve (position p) const // ?
   // ????????? ?????? ?? ??????? ? ??????
    {
        position q = search(p); // ?????????? ?? ???????
        if (q != p || q==NULL){ // ??????? ???
            return a.o; // ?????????? ????????? ??????
        }
        return q->o;
    }
    position list::  Deletex (position p) // void ????????? ???????
    {
        // ???????? ?????????? ? 
        //?????????? ?? ???????
        position q = search(p); // ?????????? ?? ???????
        if (q != p ) // ??????? ??? ? ?????? 
        {
            cout << "position doesn't exist"<<endl;
            return p;
        }
        
        if (p == begin){ // ???????? ?????? ???
            begin=p->next;
            p->next->prev=NULL;
            delete p;
            return begin; //(p->next)
        }
        //position temp =  search_pred(p);// ????? ??????????
        /*position temp = pr->begin;
        while (temp->next != p) // ??????? ??????????
            temp = temp->next;*/
        position temp = p->prev;
        if (p->next == NULL)// ???????? ??????
        {
            temp->next = NULL;
            end = temp;
            delete p;
            return temp->next; // 
        }
        // ???????? ? ????????
        temp->next = p->next;
        p->next->prev = temp;
        delete p;
        return temp->next; // ??????? p 
    }
    position list:: Next(position p) const
    {
        position q = search (p);
        if (q != p) // ??????? ???
            return a.next;
        if (p->next == NULL) // ???? p-?????????
            return NULL;
        return p->next;
    }
    position list:: Previous(position p) const // ?????????? ??????? ??????????? (q)
    {
        position q = search (p);
        if (q != p) // ??????? ???
            return a.next;
        if ( p == begin) // ???? p - ?????? , ?? ?????????? ??????? ?????????? ???????
            return a.next;
        return q->prev;
    }
    void list:: Makenull ()
    {
        position p=begin;
        while (begin!=NULL){
            begin=begin->next;
            delete p;
            p=begin;
        }
    } 
    position list:: First () const
    {
        if (begin){
            return begin;
        }
        return NULL;

    }
    void list:: Print() const
    {
        cout<<"print"<<endl;
        position p = begin;
        if (p == NULL){
            cout<< "empty" <<endl;
            return;
        }
        while (p){
           // ?????? ???????
           cout<< p->o.name<<' '<<p->o.address<<endl;
           cout<<endl;
           p=p->next;
        }
    }
}


namespace cursor
{
    struct elem;
    typedef int position; 
    struct elem
    {
        object o;
        int next;
        elem();
        int operator == (const elem& p)const;
    };
    elem:: elem() // ??? ?????????? ????????
    {
        o.name[0] = '\0';
        o.address[0] = '\0';
        next  = -1;
    }
    class list
    {
    public:
        list() ;
        //~list() { release(); }
        position End() const;
        void Insert(object x, position p);
        position Locate(object x) const;
        object& Retrieve (position p) const; // ?
        position Deletex (position p);
        position Next (position p) const;
        position Previous (position p)  const;
        void Makenull (); //
        position First () const;
        void Print() const;
        void set (char const *tname, char const *taddress);
    private:
        static int change_s(int i){return space = i;}
        position movefromspace ( object x, position next);
        position search(position p) const ;
        position search_pred(position p) const ;
        void release();
        static const int size =20;
        static elem m[size];
        //static elem m[];
        int head;
        static position space ;

    };
    elem a;//????????? ???????
   // elem list:: m[size] = {a,a,a,a,a};
    elem list:: m[size]={a};
    position list:: space = 0;
    list:: list() 
    {
        int i=0;
        head = -1; //?

        for (; i<size-1; i++)
            m[i].next = i+1;
        m[i].next = -1;
    }
    position list:: movefromspace (object x, position next)
    // ?????????? space ?? ?????????
    {
        int temp = space; 
        int s = m[space].next;  // space ????? ??????? ????????? ?? s
        m[space].next = next;
        m[space].o = x;
        space = s;
        return temp;

    }
    position list:: search(position p) const  // ????? ??????? ? ??????
    // ?????????? -1, ???? ??????? ???
    {
        int i =head;
        while ( i != -1 && i != p ){ // ?
            i=m[i].next;
        }
        return i;
    }
    position list:: search_pred(position p) const  // ????? ?????????? ??????? ? ??????
    // ??? ???????? ?? ????????????? ???????
    {
        int i = head;
        while (m[i].next != p) // ?????? ?? ??????
            i = m[i].next;
        return i;
    }
    position list:: End() const
    {
        return space;
    }
    void list:: Insert(object x, position p) // -1 ?? ???????
    {
        
        position i = search(p);
        
        if ( i == -1 && p!=space) // ??????? ??? ? ?????? ????
            return ;
        
        if (space == -1) //?? -1
            return;
        // ??????????? ?? ??????? ?????? ? ?????? 
        if (p == space) // ??????? endl
            {
                if (head == -1){ // ??????? ??????? ???????? ? ?????? ??????
                    head = movefromspace(x,-1);
                    return;
                }
                // ?????? ????????, ?????????? ? ?????
                position temp;
                temp  = search_pred(-1); // ????? ???????????
                m[temp].next = movefromspace(x,-1);
                return;
            }
            // ??????? ? ??????? (?? end)
            if (p == head){ // ? ??????
                m[head].next = movefromspace(m[head].o,m[head].next);
                m[head].o = x;
                return;
            }
            // ? ????????
            m[p].next = movefromspace(m[p].o,m[p].next);
            m[p].o = x;
            return;
    }

    position list:: Locate(object x) const
    {
        position temp = head;
        while (temp != -1 ){ //????? ?? ?????
            if ( m[temp].o == x)
                return temp;
            temp = m[temp].next;
        }
        return space; // ???? ???, ?? ?????????? ????? end(l)
    }
    object& list:: Retrieve (position p) const
    {
        position temp = head;
        while (temp != -1){ // ?????? ?? ??????
            if (temp == p)
                return m[temp].o;
            temp = m[temp].next;
        }
        return a.o;

    }
    position list::  Deletex (position p) // void ????????? ???????
    {
        // ???????? ?????????? ? 
        //?????????? ?? ???????
        position q = search(p); // ?????????? ?? ???????
        if (q != p ){ // ??????? ??? ? ?????? 
            cout << "position is missing"<<endl;
            return p;
        }
        
        if (p == head){ // ???????? ??????
            head = m[p].next;
            m[p].next = space;
            space = p;
            //head = delhead();
            return head; //(p->next)
        }
        position temp =  search_pred(p);// ????? ??????????
    
        if (m[p].next == -1){// ???????? ??????
            m[temp].next = -1;
            return m[temp].next; // 
        }
        // ???????? ? ????????
        m[temp].next = m[p].next;
        return m[temp].next; // ??????? p
    }
    position list:: Next (position p) const
    {
        position q = search(p);
        if (q == -1 || m[q].next == -1) // ??? ? ?????? ??? ????????? (temp == -1 ?? ?????????? (?))
            return space; // endl
        return m[p].next;
    }
    position list:: Previous (position p)  const
    {
        position q = search (p);
        if (q != p) // ??????? ???
            return a.next;
        if ( p == head) // ???? p - ?????? , ?? ?????????? ??????? ?????????? ???????
            return a.next;
        q = search_pred(p);// ??????? ??????? ? ???????? ?? ???????????
        return q;
    }
    void list:: Makenull ()
    {
        position temp = search_pred(-1); // ?????? ?? ??????
        m[temp].next = space;
        space = head;
        head = -1;
    }
    position list:: First () const
    {
        if (head != -1)
            return head;
        return space;

    }
    void list:: Print () const
    {
        cout<<"print"<<endl;
        if (head == -1){
            cout<< "empty" <<endl;
            return;
        }
        position p = head;
        while (p != -1){
           cout<< p<< ": " << m[p].o.name<<' '<<m[p].o.address<<endl; // ?????? ???????
           cout<<endl;
           p=m[p].next;
        }
    }

}


using namespace cursor;
void  set (list:: list *l)
{
    
    //char n[]= "John";
    //char a[]="New York";
    //x->name = n;
    object x("John","New York");
    l->Insert(x,l->End());
    position p = l->First();
    l->Insert(x,l->End());
    
    strcpy(x.name,"Amy");
    strcpy(x.address, "London");
    l->Insert(x,l->End());
    l->Insert(x,l->End());

    strcpy(x.name,"Tom");
    strcpy(x.address, "Street");
    l->Insert(x,l->End());
    l->Insert(x,l->End());
    l->Insert(x,l->End());
   // position p = l->First();
    //cout<<p->o.name<<endl;
    l->Print();
}

int main()
{
//    object *x  = new object;
   // object x( "Paul","New York" );
  //  object y( "Este","Los Angeles" );
    list l, l2;
    set(&l);
   /* set(&l2);
    cout<<"l1 ";
    l.Print();
    cout<<"l2 ";
    l2.Print();*/


   // l2.Insert(l.Retrieve(0),3);

   /* cout<<"l2 ";
    l2.Print();

    l2.Deletex(4);
    l2.Insert(l.Retrieve(0),4);
    cout<<"l2 ";
    l2.Print();
    cout<<"l1 ";
    l.Print();*/




    
    /*cout<<"start"<<endl;
    position p,q;
    p = l.First();
    //l.Insert(y,p);
    l.Print();

    //cout<<"start"<<endl;
    p = l2.End();
    //p = l.Locate(y);
    //cout<<p<<endl;
    l2.Insert(y,p);
    cout<<"l2"<<endl;
    l2.Print();
    //x = l2.Retrieve(p);

    p= 1;
    l.Deletex(p);
    cout<<"l"<<endl;
    l.Print();*/


   // p=p->next;
    //p=p->next;
    //q = l.Previous(p);
    position p  = l.First(),q;
    while (p!= l.End() ) {
        q = l.Next(p);
        while(q != l.End())
            if (l.Retrieve(p) == l.Retrieve(q)) // 
                q = l.Deletex(q);
            else
                q = l.Next(q);
        p = l.Next(p);
        
    }

    l.Print();
    l.Makenull();
    l.Print();
    
}
